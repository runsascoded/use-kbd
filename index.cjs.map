{"version":3,"sources":["../src/utils.ts","../src/useHotkeys.ts","../src/KeyboardShortcutsContext.tsx","../src/useRecordHotkey.ts","../src/useEditableHotkeys.ts","../src/useOmnibar.ts","../src/KeybindingEditor.tsx","../src/ShortcutsModal.tsx"],"names":["single","isPrefix","useState","useRef","useEffect","useCallback","createContext","useMemo","jsx","useContext","display","Fragment","jsxs"],"mappings":"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","file":"index.cjs","sourcesContent":["import type { KeyCombination, KeyCombinationDisplay, HotkeySequence } from './types'\n\n/**\n * Detect if running on macOS\n */\nexport function isMac(): boolean {\n  if (typeof navigator === 'undefined') return false\n  return /Mac|iPod|iPhone|iPad/.test(navigator.platform)\n}\n\n/**\n * Normalize a key name to a canonical form\n */\nexport function normalizeKey(key: string): string {\n  // Handle special keys\n  const keyMap: Record<string, string> = {\n    ' ': 'space',\n    'Escape': 'escape',\n    'Enter': 'enter',\n    'Tab': 'tab',\n    'Backspace': 'backspace',\n    'Delete': 'delete',\n    'ArrowUp': 'arrowup',\n    'ArrowDown': 'arrowdown',\n    'ArrowLeft': 'arrowleft',\n    'ArrowRight': 'arrowright',\n    'Home': 'home',\n    'End': 'end',\n    'PageUp': 'pageup',\n    'PageDown': 'pagedown',\n  }\n\n  if (key in keyMap) {\n    return keyMap[key]\n  }\n\n  // Single characters to lowercase\n  if (key.length === 1) {\n    return key.toLowerCase()\n  }\n\n  // Function keys (F1-F12)\n  if (/^F\\d{1,2}$/.test(key)) {\n    return key.toLowerCase()\n  }\n\n  return key.toLowerCase()\n}\n\n/**\n * Format a key for display (platform-aware)\n */\nexport function formatKeyForDisplay(key: string): string {\n  const displayMap: Record<string, string> = {\n    'space': 'Space',\n    'escape': 'Esc',\n    'enter': '',\n    'tab': 'Tab',\n    'backspace': '',\n    'delete': 'Del',\n    'arrowup': '',\n    'arrowdown': '',\n    'arrowleft': '',\n    'arrowright': '',\n    'home': 'Home',\n    'end': 'End',\n    'pageup': 'PgUp',\n    'pagedown': 'PgDn',\n  }\n\n  if (key in displayMap) {\n    return displayMap[key]\n  }\n\n  // Function keys\n  if (/^f\\d{1,2}$/.test(key)) {\n    return key.toUpperCase()\n  }\n\n  // Single letter - uppercase for display\n  if (key.length === 1) {\n    return key.toUpperCase()\n  }\n\n  return key\n}\n\n/**\n * Format a single KeyCombination (internal helper)\n */\nfunction formatSingleCombination(combo: KeyCombination): { display: string; id: string } {\n  const mac = isMac()\n  const parts: string[] = []\n  const idParts: string[] = []\n\n  // Order: Ctrl/Cmd, Alt/Option, Shift, Key\n  if (combo.modifiers.ctrl) {\n    parts.push(mac ? '' : 'Ctrl')\n    idParts.push('ctrl')\n  }\n  if (combo.modifiers.meta) {\n    parts.push(mac ? '' : 'Win')\n    idParts.push('meta')\n  }\n  if (combo.modifiers.alt) {\n    parts.push(mac ? '' : 'Alt')\n    idParts.push('alt')\n  }\n  if (combo.modifiers.shift) {\n    parts.push(mac ? '' : 'Shift')\n    idParts.push('shift')\n  }\n\n  parts.push(formatKeyForDisplay(combo.key))\n  idParts.push(combo.key)\n\n  return {\n    display: mac ? parts.join('') : parts.join('+'),\n    id: idParts.join('+'),\n  }\n}\n\n/**\n * Convert a KeyCombination or HotkeySequence to display format\n */\nexport function formatCombination(combo: KeyCombination): KeyCombinationDisplay\nexport function formatCombination(sequence: HotkeySequence): KeyCombinationDisplay\nexport function formatCombination(input: KeyCombination | HotkeySequence): KeyCombinationDisplay {\n  // Handle array (sequence)\n  if (Array.isArray(input)) {\n    if (input.length === 0) {\n      return { display: '', id: '', isSequence: false }\n    }\n    if (input.length === 1) {\n      const single = formatSingleCombination(input[0])\n      return { ...single, isSequence: false }\n    }\n    // Multiple keys = sequence\n    const formatted = input.map(formatSingleCombination)\n    return {\n      display: formatted.map(f => f.display).join(' '),\n      id: formatted.map(f => f.id).join(' '),\n      isSequence: true,\n    }\n  }\n\n  // Handle single KeyCombination\n  const single = formatSingleCombination(input)\n  return { ...single, isSequence: false }\n}\n\n/**\n * Check if a key is a modifier key\n */\nexport function isModifierKey(key: string): boolean {\n  return ['Control', 'Alt', 'Shift', 'Meta'].includes(key)\n}\n\n/**\n * Characters that require shift to type (US keyboard layout)\n * When matching these keys, we should ignore shiftKey mismatch\n */\nconst SHIFTED_CHARS = new Set([\n  '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')',\n  '_', '+', '{', '}', '|', ':', '\"', '<', '>', '?',\n])\n\n/**\n * Check if a key is a shifted character (requires shift to type)\n */\nexport function isShiftedChar(key: string): boolean {\n  return SHIFTED_CHARS.has(key)\n}\n\n/**\n * Check if a hotkey string represents a sequence (space-separated keys)\n */\nexport function isSequence(hotkeyStr: string): boolean {\n  // A sequence has spaces that aren't inside a modifier combo\n  // \"2 w\" is a sequence, \"ctrl+k\" is not, \"ctrl+k ctrl+c\" is a sequence\n  return hotkeyStr.includes(' ')\n}\n\n/**\n * Parse a single combination string (e.g., \"ctrl+k\") to KeyCombination\n */\nfunction parseSingleCombination(str: string): KeyCombination {\n  const parts = str.toLowerCase().split('+')\n  const key = parts[parts.length - 1]\n\n  return {\n    key,\n    modifiers: {\n      ctrl: parts.includes('ctrl') || parts.includes('control'),\n      alt: parts.includes('alt') || parts.includes('option'),\n      shift: parts.includes('shift'),\n      meta: parts.includes('meta') || parts.includes('cmd') || parts.includes('command'),\n    },\n  }\n}\n\n/**\n * Parse a hotkey string to a HotkeySequence.\n * Handles both single keys (\"ctrl+k\") and sequences (\"2 w\", \"ctrl+k ctrl+c\")\n */\nexport function parseHotkeyString(hotkeyStr: string): HotkeySequence {\n  if (!hotkeyStr.trim()) return []\n\n  // Split by space to get sequence parts\n  const parts = hotkeyStr.trim().split(/\\s+/)\n  return parts.map(parseSingleCombination)\n}\n\n/**\n * Parse a combination ID back to a KeyCombination (single key only)\n * @deprecated Use parseHotkeyString for sequence support\n */\nexport function parseCombinationId(id: string): KeyCombination {\n  // For backwards compatibility, if it's a sequence, return first key\n  const sequence = parseHotkeyString(id)\n  if (sequence.length === 0) {\n    return { key: '', modifiers: { ctrl: false, alt: false, shift: false, meta: false } }\n  }\n  return sequence[0]\n}\n\n/**\n * Conflict detection result\n */\nexport interface KeyConflict {\n  /** The key combination that has a conflict */\n  key: string\n  /** Actions bound to this key */\n  actions: string[]\n  /** Type of conflict */\n  type: 'duplicate' | 'prefix'\n}\n\n/**\n * Check if sequence A is a prefix of sequence B\n */\nfunction isPrefix(a: HotkeySequence, b: HotkeySequence): boolean {\n  if (a.length >= b.length) return false\n  for (let i = 0; i < a.length; i++) {\n    if (!combinationsEqual(a[i], b[i])) return false\n  }\n  return true\n}\n\n/**\n * Check if two KeyCombinations are equal\n */\nfunction combinationsEqual(a: KeyCombination, b: KeyCombination): boolean {\n  return (\n    a.key === b.key &&\n    a.modifiers.ctrl === b.modifiers.ctrl &&\n    a.modifiers.alt === b.modifiers.alt &&\n    a.modifiers.shift === b.modifiers.shift &&\n    a.modifiers.meta === b.modifiers.meta\n  )\n}\n\n/**\n * Check if two HotkeySequences are equal\n */\nfunction sequencesEqual(a: HotkeySequence, b: HotkeySequence): boolean {\n  if (a.length !== b.length) return false\n  for (let i = 0; i < a.length; i++) {\n    if (!combinationsEqual(a[i], b[i])) return false\n  }\n  return true\n}\n\n/**\n * Find conflicts in a keymap.\n * Detects:\n * - Duplicate: multiple actions bound to the exact same key/sequence\n * - Prefix: one hotkey is a prefix of another (e.g., \"2\" and \"2 w\")\n *\n * @param keymap - HotkeyMap to check for conflicts\n * @returns Map of key -> actions[] for keys with conflicts\n */\nexport function findConflicts(keymap: Record<string, string | string[]>): Map<string, string[]> {\n  const conflicts = new Map<string, string[]>()\n\n  // Parse all hotkeys into sequences for comparison\n  const entries = Object.entries(keymap).map(([key, actionOrActions]) => ({\n    key,\n    sequence: parseHotkeyString(key),\n    actions: Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions],\n  }))\n\n  // Check for duplicate keys (multiple actions on same key)\n  const keyToActions = new Map<string, string[]>()\n  for (const { key, actions } of entries) {\n    const existing = keyToActions.get(key) ?? []\n    keyToActions.set(key, [...existing, ...actions])\n  }\n  for (const [key, actions] of keyToActions) {\n    if (actions.length > 1) {\n      conflicts.set(key, actions)\n    }\n  }\n\n  // Check for prefix conflicts\n  for (let i = 0; i < entries.length; i++) {\n    for (let j = i + 1; j < entries.length; j++) {\n      const a = entries[i]\n      const b = entries[j]\n\n      // Check if a is prefix of b or b is prefix of a\n      if (isPrefix(a.sequence, b.sequence)) {\n        // a is a prefix of b - both are conflicted\n        const existingA = conflicts.get(a.key) ?? []\n        if (!existingA.includes(`prefix of: ${b.key}`)) {\n          conflicts.set(a.key, [...existingA, ...a.actions, `prefix of: ${b.key}`])\n        }\n        const existingB = conflicts.get(b.key) ?? []\n        if (!existingB.includes(`has prefix: ${a.key}`)) {\n          conflicts.set(b.key, [...existingB, ...b.actions, `has prefix: ${a.key}`])\n        }\n      } else if (isPrefix(b.sequence, a.sequence)) {\n        // b is a prefix of a\n        const existingB = conflicts.get(b.key) ?? []\n        if (!existingB.includes(`prefix of: ${a.key}`)) {\n          conflicts.set(b.key, [...existingB, ...b.actions, `prefix of: ${a.key}`])\n        }\n        const existingA = conflicts.get(a.key) ?? []\n        if (!existingA.includes(`has prefix: ${b.key}`)) {\n          conflicts.set(a.key, [...existingA, ...a.actions, `has prefix: ${b.key}`])\n        }\n      }\n    }\n  }\n\n  return conflicts\n}\n\n/**\n * Check if a keymap has any conflicts\n */\nexport function hasConflicts(keymap: Record<string, string | string[]>): boolean {\n  return findConflicts(keymap).size > 0\n}\n\n/**\n * Get conflicts as an array of KeyConflict objects\n */\nexport function getConflictsArray(keymap: Record<string, string | string[]>): KeyConflict[] {\n  const conflicts = findConflicts(keymap)\n  return Array.from(conflicts.entries()).map(([key, actions]) => ({\n    key,\n    actions: actions.filter(a => !a.startsWith('prefix of:') && !a.startsWith('has prefix:')),\n    type: actions.some(a => a.startsWith('prefix of:') || a.startsWith('has prefix:')) ? 'prefix' : 'duplicate',\n  }))\n}\n\n// ============================================================================\n// Sequence Completion Utilities\n// ============================================================================\n\nimport type { SequenceCompletion, ActionRegistry, ActionSearchResult } from './types'\n\n/**\n * Get possible completions for a partially-typed sequence.\n *\n * @example\n * ```tsx\n * const keymap = { '2 w': 'twoWeeks', '2 d': 'twoDays', 't': 'temp' }\n * const pending = parseHotkeyString('2')\n * const completions = getSequenceCompletions(pending, keymap)\n * // Returns:\n * // [\n * //   { nextKeys: 'w', fullSequence: '2 w', actions: ['twoWeeks'], ... },\n * //   { nextKeys: 'd', fullSequence: '2 d', actions: ['twoDays'], ... },\n * // ]\n * ```\n */\nexport function getSequenceCompletions(\n  pendingKeys: HotkeySequence,\n  keymap: Record<string, string | string[]>,\n): SequenceCompletion[] {\n  if (pendingKeys.length === 0) return []\n\n  const completions: SequenceCompletion[] = []\n\n  for (const [hotkeyStr, actionOrActions] of Object.entries(keymap)) {\n    const sequence = parseHotkeyString(hotkeyStr)\n\n    // Check if pending is a prefix of this sequence\n    if (sequence.length <= pendingKeys.length) continue\n\n    let isPrefix = true\n    for (let i = 0; i < pendingKeys.length; i++) {\n      if (!combinationsEqual(pendingKeys[i], sequence[i])) {\n        isPrefix = false\n        break\n      }\n    }\n\n    if (isPrefix) {\n      // Get remaining keys needed\n      const remainingKeys = sequence.slice(pendingKeys.length)\n      const nextKeys = formatCombination(remainingKeys).id\n\n      const actions = Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions]\n\n      completions.push({\n        nextKeys,\n        fullSequence: hotkeyStr,\n        display: formatCombination(sequence),\n        actions,\n      })\n    }\n  }\n\n  return completions\n}\n\n/**\n * Build a map of action -> keys[] from a keymap\n */\nexport function getActionBindings(keymap: Record<string, string | string[]>): Map<string, string[]> {\n  const actionToKeys = new Map<string, string[]>()\n\n  for (const [key, actionOrActions] of Object.entries(keymap)) {\n    const actions = Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions]\n    for (const action of actions) {\n      const existing = actionToKeys.get(action) ?? []\n      actionToKeys.set(action, [...existing, key])\n    }\n  }\n\n  return actionToKeys\n}\n\n// ============================================================================\n// Fuzzy Search Utilities\n// ============================================================================\n\n/**\n * Fuzzy match result\n */\nexport interface FuzzyMatchResult {\n  /** Whether the pattern matched */\n  matched: boolean\n  /** Match score (higher = better) */\n  score: number\n  /** Matched character ranges for highlighting [start, end] */\n  ranges: Array<[number, number]>\n}\n\n/**\n * Perform fuzzy matching of a pattern against text.\n * Returns match info including score and ranges for highlighting.\n *\n * Scoring:\n * - Consecutive matches score higher\n * - Matches at word boundaries score higher\n * - Earlier matches score higher\n */\nexport function fuzzyMatch(pattern: string, text: string): FuzzyMatchResult {\n  if (!pattern) return { matched: true, score: 1, ranges: [] }\n  if (!text) return { matched: false, score: 0, ranges: [] }\n\n  const patternLower = pattern.toLowerCase()\n  const textLower = text.toLowerCase()\n\n  let patternIdx = 0\n  let score = 0\n  let consecutiveBonus = 0\n  let lastMatchIdx = -2\n  const ranges: Array<[number, number]> = []\n  let rangeStart = -1\n\n  for (let textIdx = 0; textIdx < textLower.length && patternIdx < patternLower.length; textIdx++) {\n    if (textLower[textIdx] === patternLower[patternIdx]) {\n      // Base score for match\n      let matchScore = 1\n\n      // Bonus for consecutive matches\n      if (lastMatchIdx === textIdx - 1) {\n        consecutiveBonus += 1\n        matchScore += consecutiveBonus\n      } else {\n        consecutiveBonus = 0\n      }\n\n      // Bonus for word boundary match (start of word)\n      if (textIdx === 0 || /[\\s\\-_./]/.test(text[textIdx - 1])) {\n        matchScore += 2\n      }\n\n      // Bonus for matching uppercase (camelCase boundary)\n      if (text[textIdx] === text[textIdx].toUpperCase() && /[a-z]/.test(text[textIdx].toLowerCase())) {\n        matchScore += 1\n      }\n\n      // Penalty for later matches (prefer earlier matches)\n      matchScore -= textIdx * 0.01\n\n      score += matchScore\n      lastMatchIdx = textIdx\n      patternIdx++\n\n      // Track ranges for highlighting\n      if (rangeStart === -1) {\n        rangeStart = textIdx\n      }\n    } else {\n      // End current range\n      if (rangeStart !== -1) {\n        ranges.push([rangeStart, lastMatchIdx + 1])\n        rangeStart = -1\n      }\n    }\n  }\n\n  // Close final range\n  if (rangeStart !== -1) {\n    ranges.push([rangeStart, lastMatchIdx + 1])\n  }\n\n  const matched = patternIdx === patternLower.length\n\n  // Bonus for exact match\n  if (matched && textLower === patternLower) {\n    score += 10\n  }\n\n  // Bonus for prefix match\n  if (matched && textLower.startsWith(patternLower)) {\n    score += 5\n  }\n\n  return { matched, score, ranges }\n}\n\n/**\n * Search actions by query with fuzzy matching.\n *\n * @example\n * ```tsx\n * const results = searchActions('temp', actions, keymap)\n * // Returns ActionSearchResult[] sorted by relevance\n * ```\n */\nexport function searchActions(\n  query: string,\n  actions: ActionRegistry,\n  keymap?: Record<string, string | string[]>,\n): ActionSearchResult[] {\n  const actionBindings = keymap ? getActionBindings(keymap) : new Map<string, string[]>()\n  const results: ActionSearchResult[] = []\n\n  for (const [id, action] of Object.entries(actions)) {\n    // Skip disabled actions\n    if (action.enabled === false) continue\n\n    // Match against multiple fields\n    const labelMatch = fuzzyMatch(query, action.label)\n    const descMatch = action.description ? fuzzyMatch(query, action.description) : { matched: false, score: 0, ranges: [] }\n    const categoryMatch = action.category ? fuzzyMatch(query, action.category) : { matched: false, score: 0, ranges: [] }\n    const idMatch = fuzzyMatch(query, id)\n\n    // Check keywords\n    let keywordScore = 0\n    if (action.keywords) {\n      for (const keyword of action.keywords) {\n        const kwMatch = fuzzyMatch(query, keyword)\n        if (kwMatch.matched) {\n          keywordScore = Math.max(keywordScore, kwMatch.score)\n        }\n      }\n    }\n\n    // Calculate total score (label weighted highest)\n    const matched = labelMatch.matched || descMatch.matched || categoryMatch.matched || idMatch.matched || keywordScore > 0\n    if (!matched && query) continue\n\n    const score =\n      (labelMatch.matched ? labelMatch.score * 3 : 0) +\n      (descMatch.matched ? descMatch.score * 1.5 : 0) +\n      (categoryMatch.matched ? categoryMatch.score * 1 : 0) +\n      (idMatch.matched ? idMatch.score * 0.5 : 0) +\n      keywordScore * 2\n\n    results.push({\n      id,\n      action,\n      bindings: actionBindings.get(id) ?? [],\n      score,\n      labelMatches: labelMatch.ranges,\n    })\n  }\n\n  // Sort by score (descending)\n  results.sort((a, b) => b.score - a.score)\n\n  return results\n}\n","import { useCallback, useEffect, useRef, useState } from 'react'\nimport type { KeyCombination, HotkeySequence } from './types'\nimport {\n  isModifierKey,\n  isShiftedChar,\n  normalizeKey,\n  parseHotkeyString,\n  isSequence,\n  formatCombination,\n} from './utils'\n\n/**\n * Hotkey definition - maps key combinations/sequences to action names\n */\nexport type HotkeyMap = Record<string, string | string[]>\n\n/**\n * Handler map - maps action names to handler functions\n */\nexport type HandlerMap = Record<string, (e: KeyboardEvent) => void>\n\nexport interface UseHotkeysOptions {\n  /** Whether hotkeys are enabled (default: true) */\n  enabled?: boolean\n  /** Element to attach listeners to (default: window) */\n  target?: HTMLElement | Window | null\n  /** Prevent default on matched hotkeys (default: true) */\n  preventDefault?: boolean\n  /** Stop propagation on matched hotkeys (default: true) */\n  stopPropagation?: boolean\n  /** Enable hotkeys even when focused on input/textarea/select (default: false) */\n  enableOnFormTags?: boolean\n  /** Timeout in ms for sequences (default: 1000) */\n  sequenceTimeout?: number\n  /** What happens on timeout: 'submit' executes current sequence, 'cancel' resets (default: 'submit') */\n  onTimeout?: 'submit' | 'cancel'\n  /** Called when sequence input starts */\n  onSequenceStart?: (keys: HotkeySequence) => void\n  /** Called when sequence progresses (new key added) */\n  onSequenceProgress?: (keys: HotkeySequence) => void\n  /** Called when sequence is cancelled (timeout with 'cancel' mode, or no match) */\n  onSequenceCancel?: () => void\n}\n\nexport interface UseHotkeysResult {\n  /** Keys pressed so far in current sequence */\n  pendingKeys: HotkeySequence\n  /** Whether currently awaiting more keys in a sequence */\n  isAwaitingSequence: boolean\n  /** Cancel the current sequence */\n  cancelSequence: () => void\n  /** When the current sequence timeout started (null if not awaiting) */\n  timeoutStartedAt: number | null\n  /** The sequence timeout duration in ms */\n  sequenceTimeout: number\n}\n\n/**\n * Check if a keyboard event matches a KeyCombination\n */\nfunction matchesCombination(e: KeyboardEvent, combo: KeyCombination): boolean {\n  const eventKey = normalizeKey(e.key)\n\n  // For shifted characters (like ?, !, @), ignore shift key mismatch\n  const shiftMatches = isShiftedChar(e.key)\n    ? (combo.modifiers.shift ? e.shiftKey : true)\n    : e.shiftKey === combo.modifiers.shift\n\n  return (\n    e.ctrlKey === combo.modifiers.ctrl &&\n    e.altKey === combo.modifiers.alt &&\n    shiftMatches &&\n    e.metaKey === combo.modifiers.meta &&\n    eventKey === combo.key\n  )\n}\n\n/**\n * Create a KeyCombination from a KeyboardEvent\n */\nfunction eventToCombination(e: KeyboardEvent): KeyCombination {\n  return {\n    key: normalizeKey(e.key),\n    modifiers: {\n      ctrl: e.ctrlKey,\n      alt: e.altKey,\n      shift: e.shiftKey,\n      meta: e.metaKey,\n    },\n  }\n}\n\n/**\n * Check if a pending sequence matches the start of a hotkey sequence\n */\nfunction isPartialMatch(pending: HotkeySequence, target: HotkeySequence): boolean {\n  if (pending.length >= target.length) return false\n  for (let i = 0; i < pending.length; i++) {\n    if (!combinationsMatch(pending[i], target[i])) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Check if two key combinations match (handles shifted chars like ?)\n */\nfunction combinationsMatch(event: KeyCombination, target: KeyCombination): boolean {\n  // For shifted characters (like ?, !, @), ignore shift key mismatch\n  const shiftMatches = isShiftedChar(event.key)\n    ? (target.modifiers.shift ? event.modifiers.shift : true)\n    : event.modifiers.shift === target.modifiers.shift\n\n  return (\n    event.modifiers.ctrl === target.modifiers.ctrl &&\n    event.modifiers.alt === target.modifiers.alt &&\n    shiftMatches &&\n    event.modifiers.meta === target.modifiers.meta &&\n    event.key === target.key\n  )\n}\n\n/**\n * Check if two sequences are exactly equal\n */\nfunction sequencesMatch(a: HotkeySequence, b: HotkeySequence): boolean {\n  if (a.length !== b.length) return false\n  for (let i = 0; i < a.length; i++) {\n    if (!combinationsMatch(a[i], b[i])) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Hook to register keyboard shortcuts with sequence support.\n *\n * @example\n * ```tsx\n * // Single keys\n * const { pendingKeys } = useHotkeys(\n *   { 't': 'setTemp', 'ctrl+s': 'save' },\n *   { setTemp: () => setMetric('temp'), save: handleSave }\n * )\n *\n * // Sequences\n * const { pendingKeys, isAwaitingSequence } = useHotkeys(\n *   { '2 w': 'twoWeeks', '2 d': 'twoDays' },\n *   { twoWeeks: () => setRange('2w'), twoDays: () => setRange('2d') },\n *   { sequenceTimeout: 1000 }\n * )\n * ```\n */\nexport function useHotkeys(\n  keymap: HotkeyMap,\n  handlers: HandlerMap,\n  options: UseHotkeysOptions = {},\n): UseHotkeysResult {\n  const {\n    enabled = true,\n    target,\n    preventDefault = true,\n    stopPropagation = true,\n    enableOnFormTags = false,\n    sequenceTimeout = 1000,\n    onTimeout = 'submit',\n    onSequenceStart,\n    onSequenceProgress,\n    onSequenceCancel,\n  } = options\n\n  const [pendingKeys, setPendingKeys] = useState<HotkeySequence>([])\n  const [isAwaitingSequence, setIsAwaitingSequence] = useState(false)\n  const [timeoutStartedAt, setTimeoutStartedAt] = useState<number | null>(null)\n\n  // Use refs for handlers to avoid re-attaching listeners\n  const handlersRef = useRef(handlers)\n  handlersRef.current = handlers\n\n  const keymapRef = useRef(keymap)\n  keymapRef.current = keymap\n\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)\n\n  // Use ref for pendingKeys to avoid stale closure in event handlers\n  const pendingKeysRef = useRef<HotkeySequence>([])\n  pendingKeysRef.current = pendingKeys\n\n  // Parse keymap into sequences for matching\n  const parsedKeymapRef = useRef<Array<{ key: string; sequence: HotkeySequence; actions: string[] }>>([])\n\n  useEffect(() => {\n    parsedKeymapRef.current = Object.entries(keymap).map(([key, actionOrActions]) => ({\n      key,\n      sequence: parseHotkeyString(key),\n      actions: Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions],\n    }))\n  }, [keymap])\n\n  const clearPending = useCallback(() => {\n    setPendingKeys([])\n    setIsAwaitingSequence(false)\n    setTimeoutStartedAt(null)\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current)\n      timeoutRef.current = null\n    }\n  }, [])\n\n  const cancelSequence = useCallback(() => {\n    clearPending()\n    onSequenceCancel?.()\n  }, [clearPending, onSequenceCancel])\n\n  // Try to execute a handler for the given sequence\n  const tryExecute = useCallback((\n    sequence: HotkeySequence,\n    e: KeyboardEvent,\n  ): boolean => {\n    for (const entry of parsedKeymapRef.current) {\n      if (sequencesMatch(sequence, entry.sequence)) {\n        for (const action of entry.actions) {\n          const handler = handlersRef.current[action]\n          if (handler) {\n            if (preventDefault) {\n              e.preventDefault()\n            }\n            if (stopPropagation) {\n              e.stopPropagation()\n            }\n            handler(e)\n            return true\n          }\n        }\n      }\n    }\n    return false\n  }, [preventDefault, stopPropagation])\n\n  // Check if sequence has any potential matches (partial or full)\n  const hasPotentialMatch = useCallback((sequence: HotkeySequence): boolean => {\n    for (const entry of parsedKeymapRef.current) {\n      if (isPartialMatch(sequence, entry.sequence) || sequencesMatch(sequence, entry.sequence)) {\n        return true\n      }\n    }\n    return false\n  }, [])\n\n  // Check if there are any sequences that start with current pending\n  const hasSequenceExtension = useCallback((sequence: HotkeySequence): boolean => {\n    for (const entry of parsedKeymapRef.current) {\n      if (entry.sequence.length > sequence.length && isPartialMatch(sequence, entry.sequence)) {\n        return true\n      }\n    }\n    return false\n  }, [])\n\n  useEffect(() => {\n    if (!enabled) return\n\n    const targetElement = target ?? window\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Skip if focused on form element (unless enabled)\n      if (!enableOnFormTags) {\n        const eventTarget = e.target as HTMLElement\n        if (\n          eventTarget instanceof HTMLInputElement ||\n          eventTarget instanceof HTMLTextAreaElement ||\n          eventTarget instanceof HTMLSelectElement ||\n          eventTarget.isContentEditable\n        ) {\n          return\n        }\n      }\n\n      // Skip modifier-only keypresses\n      if (isModifierKey(e.key)) {\n        return\n      }\n\n      // Clear any existing timeout\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n        timeoutRef.current = null\n      }\n\n      // Enter key submits current sequence\n      if (e.key === 'Enter' && pendingKeysRef.current.length > 0) {\n        e.preventDefault()\n        const executed = tryExecute(pendingKeysRef.current, e)\n        clearPending()\n        if (!executed) {\n          onSequenceCancel?.()\n        }\n        return\n      }\n\n      // Escape cancels current sequence\n      if (e.key === 'Escape' && pendingKeysRef.current.length > 0) {\n        e.preventDefault()\n        cancelSequence()\n        return\n      }\n\n      // Add current key to sequence\n      const currentCombo = eventToCombination(e)\n      const newSequence = [...pendingKeysRef.current, currentCombo]\n\n      // Check for exact match first\n      const exactMatch = tryExecute(newSequence, e)\n      if (exactMatch) {\n        clearPending()\n        return\n      }\n\n      // Check if this could be the start of a longer sequence\n      if (hasPotentialMatch(newSequence)) {\n        // Check if there are longer sequences this could match\n        if (hasSequenceExtension(newSequence)) {\n          // Wait for more keys\n          setPendingKeys(newSequence)\n          setIsAwaitingSequence(true)\n\n          if (pendingKeysRef.current.length === 0) {\n            onSequenceStart?.(newSequence)\n          } else {\n            onSequenceProgress?.(newSequence)\n          }\n\n          // Set timeout\n          setTimeoutStartedAt(Date.now())\n          timeoutRef.current = setTimeout(() => {\n            if (onTimeout === 'submit') {\n              // Try to execute whatever we have\n              // Note: We need to get the current pending keys from state\n              setPendingKeys(current => {\n                if (current.length > 0) {\n                  // We can't call tryExecute here because we don't have the event\n                  // So we'll just clear and call onSequenceCancel\n                  onSequenceCancel?.()\n                }\n                return []\n              })\n              setIsAwaitingSequence(false)\n              setTimeoutStartedAt(null)\n            } else {\n              // Cancel mode\n              setPendingKeys([])\n              setIsAwaitingSequence(false)\n              setTimeoutStartedAt(null)\n              onSequenceCancel?.()\n            }\n            timeoutRef.current = null\n          }, sequenceTimeout)\n\n          // Prevent default for potential sequence keys\n          if (preventDefault) {\n            e.preventDefault()\n          }\n          return\n        }\n      }\n\n      // No match and no potential - reset and try single key\n      if (pendingKeysRef.current.length > 0) {\n        clearPending()\n        onSequenceCancel?.()\n      }\n\n      // Try as single key (sequence of 1)\n      const singleMatch = tryExecute([currentCombo], e)\n      if (!singleMatch) {\n        // Check if single key could start a sequence\n        if (hasSequenceExtension([currentCombo])) {\n          setPendingKeys([currentCombo])\n          setIsAwaitingSequence(true)\n          onSequenceStart?.([currentCombo])\n\n          if (preventDefault) {\n            e.preventDefault()\n          }\n\n          // Set timeout\n          setTimeoutStartedAt(Date.now())\n          timeoutRef.current = setTimeout(() => {\n            if (onTimeout === 'submit') {\n              setPendingKeys([])\n              setIsAwaitingSequence(false)\n              setTimeoutStartedAt(null)\n              onSequenceCancel?.()\n            } else {\n              setPendingKeys([])\n              setIsAwaitingSequence(false)\n              setTimeoutStartedAt(null)\n              onSequenceCancel?.()\n            }\n            timeoutRef.current = null\n          }, sequenceTimeout)\n        }\n      }\n    }\n\n    targetElement.addEventListener('keydown', handleKeyDown as EventListener)\n\n    return () => {\n      targetElement.removeEventListener('keydown', handleKeyDown as EventListener)\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n    }\n  }, [\n    enabled,\n    target,\n    preventDefault,\n    stopPropagation,\n    enableOnFormTags,\n    sequenceTimeout,\n    onTimeout,\n    clearPending,\n    cancelSequence,\n    tryExecute,\n    hasPotentialMatch,\n    hasSequenceExtension,\n    onSequenceStart,\n    onSequenceProgress,\n    onSequenceCancel,\n  ])\n\n  return { pendingKeys, isAwaitingSequence, cancelSequence, timeoutStartedAt, sequenceTimeout }\n}\n","import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react'\nimport type { ActionRegistry, ActionSearchResult, HotkeySequence, SequenceCompletion } from './types'\nimport { useHotkeys, HotkeyMap, HandlerMap, UseHotkeysOptions, UseHotkeysResult } from './useHotkeys'\nimport { findConflicts, searchActions, getSequenceCompletions, getActionBindings } from './utils'\n\nexport interface KeyboardShortcutsContextValue {\n  /** Default keymap (before user overrides) */\n  defaults: HotkeyMap\n  /** Current keymap (defaults merged with user overrides) */\n  keymap: HotkeyMap\n  /** Registry of available actions (if provided) */\n  actions: ActionRegistry\n  /** Update a single keybinding (replaces existing binding for the action) */\n  setBinding: (action: string, key: string) => void\n  /** Add a new key binding for an action (keeps existing bindings) */\n  addBinding: (action: string, key: string) => void\n  /** Remove a key binding */\n  removeBinding: (key: string) => void\n  /** Update multiple keybindings at once */\n  setKeymap: (overrides: Partial<HotkeyMap>) => void\n  /** Reset all overrides to defaults */\n  reset: () => void\n  /** User overrides only (for inspection/export) */\n  overrides: Partial<HotkeyMap>\n  /** Map of key -> actions[] for keys with multiple actions bound */\n  conflicts: Map<string, string[]>\n  /** Whether there are any conflicts in the current keymap */\n  hasConflicts: boolean\n  /** When true, keys with multiple actions bound are disabled */\n  disableConflicts: boolean\n  /** Search actions by query */\n  searchActions: (query: string) => ActionSearchResult[]\n  /** Get sequence completions for pending keys */\n  getCompletions: (pendingKeys: HotkeySequence) => SequenceCompletion[]\n  /** Get all bindings for an action */\n  getBindingsForAction: (actionId: string) => string[]\n}\n\nconst KeyboardShortcutsContext = createContext<KeyboardShortcutsContextValue | null>(null)\n\nexport interface KeyboardShortcutsProviderProps {\n  /** Default hotkey map */\n  defaults: HotkeyMap\n  /** Registry of available actions (for omnibar and action management) */\n  actions?: ActionRegistry\n  /** localStorage key for persistence (omit to disable persistence) */\n  storageKey?: string\n  /** When true, keys with multiple actions bound are disabled (default: true) */\n  disableConflicts?: boolean\n  children: React.ReactNode\n}\n\n/**\n * Provider for keyboard shortcuts context.\n * Manages the keymap, user overrides, persistence, and conflict detection.\n *\n * @example\n * ```tsx\n * <KeyboardShortcutsProvider\n *   defaults={{ 't': 'setTemp', 'c': 'setCO2' }}\n *   storageKey=\"app-hotkeys\"\n * >\n *   <App />\n * </KeyboardShortcutsProvider>\n * ```\n */\nexport function KeyboardShortcutsProvider({\n  defaults,\n  actions: actionsProp = {},\n  storageKey,\n  disableConflicts = true,\n  children,\n}: KeyboardShortcutsProviderProps) {\n  // Load overrides from storage on mount\n  const [overrides, setOverrides] = useState<Partial<HotkeyMap>>(() => {\n    if (!storageKey || typeof window === 'undefined') return {}\n    try {\n      const stored = localStorage.getItem(storageKey)\n      return stored ? JSON.parse(stored) : {}\n    } catch {\n      return {}\n    }\n  })\n\n  // Persist overrides to storage\n  useEffect(() => {\n    if (!storageKey || typeof window === 'undefined') return\n    try {\n      if (Object.keys(overrides).length === 0) {\n        localStorage.removeItem(storageKey)\n      } else {\n        localStorage.setItem(storageKey, JSON.stringify(overrides))\n      }\n    } catch {\n      // Ignore storage errors\n    }\n  }, [storageKey, overrides])\n\n  // Merge defaults with overrides\n  const keymap = useMemo(() => {\n    // Track removed keys (marked with empty string in overrides)\n    const removedKeys = new Set<string>()\n    for (const [key, action] of Object.entries(overrides)) {\n      if (action === '') {\n        removedKeys.add(key)\n      }\n    }\n\n    // Build action -> keys map from defaults (excluding removed)\n    const actionToKeys: Record<string, string[]> = {}\n    for (const [key, action] of Object.entries(defaults)) {\n      if (removedKeys.has(key)) continue\n      const actions = Array.isArray(action) ? action : [action]\n      for (const a of actions) {\n        if (!actionToKeys[a]) actionToKeys[a] = []\n        actionToKeys[a].push(key)\n      }\n    }\n\n    // Apply overrides (key -> action), excluding removed markers\n    for (const [key, action] of Object.entries(overrides)) {\n      if (action === undefined || action === '') continue\n      const actions = Array.isArray(action) ? action : [action]\n      for (const a of actions) {\n        if (!actionToKeys[a]) actionToKeys[a] = []\n        if (!actionToKeys[a].includes(key)) {\n          actionToKeys[a].push(key)\n        }\n      }\n    }\n\n    // Rebuild key -> action map\n    const result: HotkeyMap = {}\n    for (const [action, keys] of Object.entries(actionToKeys)) {\n      for (const key of keys) {\n        if (result[key]) {\n          const existing = result[key]\n          result[key] = Array.isArray(existing) ? [...existing, action] : [existing, action]\n        } else {\n          result[key] = action\n        }\n      }\n    }\n\n    return result\n  }, [defaults, overrides])\n\n  // Compute conflicts from current keymap\n  const conflicts = useMemo(() => findConflicts(keymap), [keymap])\n  const hasConflictsValue = conflicts.size > 0\n\n  // Action bindings map\n  const actionBindings = useMemo(() => getActionBindings(keymap), [keymap])\n\n  // Search actions helper\n  const searchActionsInContext = useCallback(\n    (query: string) => searchActions(query, actionsProp, keymap),\n    [actionsProp, keymap],\n  )\n\n  // Get sequence completions helper\n  const getCompletions = useCallback(\n    (pendingKeys: HotkeySequence) => getSequenceCompletions(pendingKeys, keymap),\n    [keymap],\n  )\n\n  // Get bindings for action helper\n  const getBindingsForAction = useCallback(\n    (actionId: string) => actionBindings.get(actionId) ?? [],\n    [actionBindings],\n  )\n\n  const setBinding = useCallback((action: string, key: string) => {\n    setOverrides((prev) => {\n      // Find default keys that map to this action and mark them as removed\n      const result: Partial<HotkeyMap> = {}\n\n      // Mark default keys for this action as removed (unless it's the new key)\n      for (const [k, v] of Object.entries(defaults)) {\n        const actions = Array.isArray(v) ? v : [v]\n        if (actions.includes(action) && k !== key) {\n          result[k] = '' // Mark as removed\n        }\n      }\n\n      // Copy previous overrides, excluding any that map a different key to this action\n      for (const [k, v] of Object.entries(prev)) {\n        const actions = Array.isArray(v) ? v : [v]\n        if (k === key || !actions.includes(action)) {\n          result[k] = v\n        }\n      }\n\n      // Add the new binding\n      result[key] = action\n      return result\n    })\n  }, [defaults])\n\n  const addBinding = useCallback((action: string, key: string) => {\n    setOverrides((prev) => {\n      // Simply add the new key -> action binding without removing existing ones\n      return { ...prev, [key]: action }\n    })\n  }, [])\n\n  const removeBinding = useCallback((key: string) => {\n    setOverrides((prev) => {\n      // Check if this key is in defaults\n      const isDefault = key in defaults\n      if (isDefault) {\n        // Mark as removed by setting to empty string (special marker)\n        return { ...prev, [key]: '' }\n      } else {\n        // Remove from overrides\n        const { [key]: _removed, ...rest } = prev\n        return rest\n      }\n    })\n  }, [defaults])\n\n  const setKeymap = useCallback((newOverrides: Partial<HotkeyMap>) => {\n    setOverrides((prev) => ({ ...prev, ...newOverrides }))\n  }, [])\n\n  const reset = useCallback(() => {\n    setOverrides({})\n  }, [])\n\n  const value = useMemo<KeyboardShortcutsContextValue>(\n    () => ({\n      defaults,\n      keymap,\n      actions: actionsProp,\n      setBinding,\n      addBinding,\n      removeBinding,\n      setKeymap,\n      reset,\n      overrides,\n      conflicts,\n      hasConflicts: hasConflictsValue,\n      disableConflicts,\n      searchActions: searchActionsInContext,\n      getCompletions,\n      getBindingsForAction,\n    }),\n    [defaults, keymap, actionsProp, setBinding, addBinding, removeBinding, setKeymap, reset, overrides, conflicts, hasConflictsValue, disableConflicts, searchActionsInContext, getCompletions, getBindingsForAction],\n  )\n\n  return (\n    <KeyboardShortcutsContext.Provider value={value}>\n      {children}\n    </KeyboardShortcutsContext.Provider>\n  )\n}\n\n/**\n * Hook to access the keyboard shortcuts context.\n * Must be used within a KeyboardShortcutsProvider.\n *\n * @example\n * ```tsx\n * const { keymap, setBinding, conflicts } = useKeyboardShortcutsContext()\n * ```\n */\nexport function useKeyboardShortcutsContext(): KeyboardShortcutsContextValue {\n  const context = useContext(KeyboardShortcutsContext)\n  if (!context) {\n    throw new Error('useKeyboardShortcutsContext must be used within a KeyboardShortcutsProvider')\n  }\n  return context\n}\n\n/**\n * Hook to register hotkey handlers using the keymap from context.\n * Automatically excludes conflicting keys if disableConflicts is true.\n *\n * @example\n * ```tsx\n * useRegisteredHotkeys({\n *   setTemp: () => setMetric('temp'),\n *   setCO2: () => setMetric('co2'),\n * })\n * ```\n */\nexport function useRegisteredHotkeys(\n  handlers: HandlerMap,\n  options: Omit<UseHotkeysOptions, 'enabled'> & { enabled?: boolean } = {},\n): UseHotkeysResult {\n  const { keymap, conflicts, disableConflicts } = useKeyboardShortcutsContext()\n\n  // Effective keymap - removes conflicting keys if disableConflicts is true\n  const effectiveKeymap = useMemo(() => {\n    if (!disableConflicts || conflicts.size === 0) {\n      return keymap\n    }\n    // Filter out keys that have conflicts\n    const filtered: HotkeyMap = {}\n    for (const [key, action] of Object.entries(keymap)) {\n      if (!conflicts.has(key)) {\n        filtered[key] = action\n      }\n    }\n    return filtered\n  }, [keymap, conflicts, disableConflicts])\n\n  return useHotkeys(effectiveKeymap, handlers, options)\n}\n","import { useCallback, useEffect, useRef, useState } from 'react'\nimport type { KeyCombination, HotkeySequence, RecordHotkeyOptions, RecordHotkeyResult } from './types'\nimport { formatCombination, isModifierKey, normalizeKey } from './utils'\n\n/** Store callback in ref to avoid effect re-runs when callback changes */\nfunction useEventCallback<T extends (...args: never[]) => unknown>(fn: T | undefined): T | undefined {\n  const ref = useRef(fn)\n  ref.current = fn\n  return useCallback(((...args) => ref.current?.(...args)) as T, [])\n}\n\n/**\n * Hook to record a keyboard shortcut (single key or sequence) from user input.\n *\n * Recording behavior:\n * - Each key press (after modifiers released) adds to the sequence\n * - Enter key submits the current sequence\n * - Timeout submits the current sequence (configurable)\n * - Escape cancels recording\n *\n * @example\n * ```tsx\n * function KeybindingEditor() {\n *   const { isRecording, startRecording, sequence, display, pendingKeys, activeKeys } = useRecordHotkey({\n *     onCapture: (sequence, display) => {\n *       console.log('Captured:', display.display) // \"2 W\" or \"K\"\n *       saveKeybinding(display.id) // \"2 w\" or \"meta+k\"\n *     },\n *     sequenceTimeout: 1000,\n *   })\n *\n *   return (\n *     <button onClick={() => startRecording()}>\n *       {isRecording\n *         ? (pendingKeys.length > 0\n *             ? formatCombination(pendingKeys).display + '...'\n *             : 'Press keys...')\n *         : (display?.display ?? 'Click to set')}\n *     </button>\n *   )\n * }\n * ```\n */\nexport function useRecordHotkey(options: RecordHotkeyOptions = {}): RecordHotkeyResult {\n  const {\n    onCapture: onCaptureProp,\n    onCancel: onCancelProp,\n    preventDefault = true,\n    sequenceTimeout = 1000,\n  } = options\n\n  // Stabilize callbacks to avoid effect re-runs\n  const onCapture = useEventCallback(onCaptureProp)\n  const onCancel = useEventCallback(onCancelProp)\n\n  const [isRecording, setIsRecording] = useState(false)\n  const [sequence, setSequence] = useState<HotkeySequence | null>(null)\n  const [pendingKeys, setPendingKeys] = useState<HotkeySequence>([])\n  const [activeKeys, setActiveKeys] = useState<KeyCombination | null>(null)\n\n  // Track pressed keys during recording\n  const pressedKeysRef = useRef<Set<string>>(new Set())\n  const hasNonModifierRef = useRef(false)\n  const currentComboRef = useRef<KeyCombination | null>(null)\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)\n\n  const clearTimeout_ = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current)\n      timeoutRef.current = null\n    }\n  }, [])\n\n  const submit = useCallback((seq: HotkeySequence) => {\n    if (seq.length === 0) return\n\n    const display = formatCombination(seq)\n\n    // Clear state\n    clearTimeout_()\n    pressedKeysRef.current.clear()\n    hasNonModifierRef.current = false\n    currentComboRef.current = null\n\n    setSequence(seq)\n    setPendingKeys([])\n    setIsRecording(false)\n    setActiveKeys(null)\n\n    onCapture?.(seq, display)\n  }, [clearTimeout_, onCapture])\n\n  const cancel = useCallback(() => {\n    clearTimeout_()\n    setIsRecording(false)\n    setPendingKeys([])\n    setActiveKeys(null)\n    pressedKeysRef.current.clear()\n    hasNonModifierRef.current = false\n    currentComboRef.current = null\n    onCancel?.()\n  }, [clearTimeout_, onCancel])\n\n  const startRecording = useCallback(() => {\n    clearTimeout_()\n    setIsRecording(true)\n    setSequence(null)\n    setPendingKeys([])\n    setActiveKeys(null)\n    pressedKeysRef.current.clear()\n    hasNonModifierRef.current = false\n    currentComboRef.current = null\n\n    // Return cancel function\n    return cancel\n  }, [cancel, clearTimeout_])\n\n  useEffect(() => {\n    if (!isRecording) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (preventDefault) {\n        e.preventDefault()\n        e.stopPropagation()\n      }\n\n      // Clear timeout on any keypress\n      clearTimeout_()\n\n      // Enter submits current sequence\n      if (e.key === 'Enter') {\n        setPendingKeys(current => {\n          if (current.length > 0) {\n            submit(current)\n          }\n          return current\n        })\n        return\n      }\n\n      // Escape cancels\n      if (e.key === 'Escape') {\n        cancel()\n        return\n      }\n\n      const key = e.key\n      pressedKeysRef.current.add(key)\n\n      // Build current combination from pressed keys\n      const combo: KeyCombination = {\n        key: '',\n        modifiers: {\n          ctrl: e.ctrlKey,\n          alt: e.altKey,\n          shift: e.shiftKey,\n          meta: e.metaKey,\n        },\n      }\n\n      // Find the non-modifier key\n      for (const k of pressedKeysRef.current) {\n        if (!isModifierKey(k)) {\n          combo.key = normalizeKey(k)\n          hasNonModifierRef.current = true\n          break\n        }\n      }\n\n      // Only update if we have a non-modifier key\n      if (combo.key) {\n        currentComboRef.current = combo\n        setActiveKeys(combo)\n      } else {\n        // Show modifiers being held\n        setActiveKeys({\n          key: '',\n          modifiers: combo.modifiers,\n        })\n      }\n    }\n\n    const handleKeyUp = (e: KeyboardEvent) => {\n      if (preventDefault) {\n        e.preventDefault()\n        e.stopPropagation()\n      }\n\n      pressedKeysRef.current.delete(e.key)\n\n      // On Mac, releasing Meta swallows other keyup events, so check if we have a valid\n      // combination when Meta is released (or when all keys are released)\n      const shouldComplete =\n        (pressedKeysRef.current.size === 0) ||\n        (e.key === 'Meta' && hasNonModifierRef.current)\n\n      if (shouldComplete && hasNonModifierRef.current && currentComboRef.current) {\n        const combo = currentComboRef.current\n\n        // Clear for next key in sequence\n        pressedKeysRef.current.clear()\n        hasNonModifierRef.current = false\n        currentComboRef.current = null\n        setActiveKeys(null)\n\n        // Add to pending sequence\n        setPendingKeys(current => {\n          const newSequence = [...current, combo]\n\n          // Set timeout to submit\n          clearTimeout_()\n          timeoutRef.current = setTimeout(() => {\n            submit(newSequence)\n          }, sequenceTimeout)\n\n          return newSequence\n        })\n      }\n    }\n\n    // Capture phase to intercept before other handlers\n    window.addEventListener('keydown', handleKeyDown, true)\n    window.addEventListener('keyup', handleKeyUp, true)\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, true)\n      window.removeEventListener('keyup', handleKeyUp, true)\n      clearTimeout_()\n    }\n  }, [isRecording, preventDefault, sequenceTimeout, clearTimeout_, submit, cancel])\n\n  const display = sequence ? formatCombination(sequence) : null\n\n  // Backwards compatibility: return first key as combination\n  const combination = sequence && sequence.length > 0 ? sequence[0] : null\n\n  return {\n    isRecording,\n    startRecording,\n    cancel,\n    sequence,\n    display,\n    pendingKeys,\n    activeKeys,\n    combination, // deprecated\n  }\n}\n","import { useCallback, useEffect, useMemo, useState } from 'react'\nimport type { HotkeySequence } from './types'\nimport { useHotkeys, HotkeyMap, HandlerMap, UseHotkeysOptions } from './useHotkeys'\nimport { findConflicts } from './utils'\n\nexport interface UseEditableHotkeysOptions extends UseHotkeysOptions {\n  /** localStorage key for persistence (omit to disable persistence) */\n  storageKey?: string\n  /** When true, keys with multiple actions bound are disabled (default: true) */\n  disableConflicts?: boolean\n}\n\nexport interface UseEditableHotkeysResult {\n  /** Current keymap (defaults merged with user overrides) */\n  keymap: HotkeyMap\n  /** Update a single keybinding */\n  setBinding: (action: string, key: string) => void\n  /** Update multiple keybindings at once */\n  setKeymap: (overrides: Partial<HotkeyMap>) => void\n  /** Reset all overrides to defaults */\n  reset: () => void\n  /** User overrides only (for inspection/export) */\n  overrides: Partial<HotkeyMap>\n  /** Map of key -> actions[] for keys with multiple actions bound */\n  conflicts: Map<string, string[]>\n  /** Whether there are any conflicts in the current keymap */\n  hasConflicts: boolean\n  /** Keys pressed so far in current sequence */\n  pendingKeys: HotkeySequence\n  /** Whether currently awaiting more keys in a sequence */\n  isAwaitingSequence: boolean\n  /** Cancel the current sequence */\n  cancelSequence: () => void\n  /** When the current sequence timeout started (null if not awaiting) */\n  timeoutStartedAt: number | null\n  /** The sequence timeout duration in ms */\n  sequenceTimeout: number\n}\n\n/**\n * Wraps useHotkeys with editable keybindings and optional persistence.\n *\n * @example\n * ```tsx\n * const { keymap, setBinding, reset } = useEditableHotkeys(\n *   { 't': 'setTemp', 'c': 'setCO2' },\n *   { setTemp: () => setMetric('temp'), setCO2: () => setMetric('co2') },\n *   { storageKey: 'app-hotkeys' }\n * )\n * ```\n */\nexport function useEditableHotkeys(\n  defaults: HotkeyMap,\n  handlers: HandlerMap,\n  options: UseEditableHotkeysOptions = {},\n): UseEditableHotkeysResult {\n  const { storageKey, disableConflicts = true, ...hotkeyOptions } = options\n\n  // Load overrides from storage on mount\n  const [overrides, setOverrides] = useState<Partial<HotkeyMap>>(() => {\n    if (!storageKey || typeof window === 'undefined') return {}\n    try {\n      const stored = localStorage.getItem(storageKey)\n      return stored ? JSON.parse(stored) : {}\n    } catch {\n      return {}\n    }\n  })\n\n  // Persist overrides to storage\n  useEffect(() => {\n    if (!storageKey || typeof window === 'undefined') return\n    try {\n      if (Object.keys(overrides).length === 0) {\n        localStorage.removeItem(storageKey)\n      } else {\n        localStorage.setItem(storageKey, JSON.stringify(overrides))\n      }\n    } catch {\n      // Ignore storage errors\n    }\n  }, [storageKey, overrides])\n\n  // Merge defaults with overrides (invert the map: action -> key becomes key -> action)\n  const keymap = useMemo(() => {\n    // Build action -> key map from defaults\n    const actionToKey: Record<string, string> = {}\n    for (const [key, action] of Object.entries(defaults)) {\n      const actions = Array.isArray(action) ? action : [action]\n      for (const a of actions) {\n        actionToKey[a] = key\n      }\n    }\n\n    // Apply overrides (key -> action)\n    for (const [key, action] of Object.entries(overrides)) {\n      if (action === undefined) continue\n      const actions = Array.isArray(action) ? action : [action]\n      for (const a of actions) {\n        actionToKey[a] = key\n      }\n    }\n\n    // Rebuild key -> action map\n    const result: HotkeyMap = {}\n    for (const [action, key] of Object.entries(actionToKey)) {\n      if (result[key]) {\n        const existing = result[key]\n        result[key] = Array.isArray(existing) ? [...existing, action] : [existing, action]\n      } else {\n        result[key] = action\n      }\n    }\n\n    return result\n  }, [defaults, overrides])\n\n  // Compute conflicts from current keymap\n  const conflicts = useMemo(() => findConflicts(keymap), [keymap])\n  const hasConflictsValue = conflicts.size > 0\n\n  // Effective keymap for useHotkeys - removes conflicting keys if disableConflicts is true\n  const effectiveKeymap = useMemo(() => {\n    if (!disableConflicts || conflicts.size === 0) {\n      return keymap\n    }\n    // Filter out keys that have conflicts\n    const filtered: HotkeyMap = {}\n    for (const [key, action] of Object.entries(keymap)) {\n      if (!conflicts.has(key)) {\n        filtered[key] = action\n      }\n    }\n    return filtered\n  }, [keymap, conflicts, disableConflicts])\n\n  // Register hotkeys (using effective keymap that excludes conflicts)\n  const { pendingKeys, isAwaitingSequence, cancelSequence, timeoutStartedAt, sequenceTimeout } = useHotkeys(effectiveKeymap, handlers, hotkeyOptions)\n\n  const setBinding = useCallback((action: string, key: string) => {\n    setOverrides((prev) => {\n      // Remove any existing override that maps a different key to this action\n      const cleaned: Partial<HotkeyMap> = {}\n      for (const [k, v] of Object.entries(prev)) {\n        // Keep the entry unless it's a different key mapping to the same action\n        const actions = Array.isArray(v) ? v : [v]\n        if (k === key || !actions.includes(action)) {\n          cleaned[k] = v\n        }\n      }\n      // Add the new binding\n      return { ...cleaned, [key]: action }\n    })\n  }, [])\n\n  const setKeymap = useCallback((newOverrides: Partial<HotkeyMap>) => {\n    setOverrides((prev) => ({ ...prev, ...newOverrides }))\n  }, [])\n\n  const reset = useCallback(() => {\n    setOverrides({})\n  }, [])\n\n  return {\n    keymap,\n    setBinding,\n    setKeymap,\n    reset,\n    overrides,\n    conflicts,\n    hasConflicts: hasConflictsValue,\n    pendingKeys,\n    isAwaitingSequence,\n    cancelSequence,\n    timeoutStartedAt,\n    sequenceTimeout,\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport type { ActionRegistry, ActionSearchResult, HotkeySequence } from './types'\nimport { useHotkeys, HotkeyMap, HandlerMap } from './useHotkeys'\nimport { searchActions, getSequenceCompletions, formatCombination } from './utils'\nimport type { SequenceCompletion } from './types'\n\nexport interface UseOmnibarOptions {\n  /** Registry of available actions */\n  actions: ActionRegistry\n  /** Handlers for actions (optional - if not provided, use onExecute callback) */\n  handlers?: HandlerMap\n  /** Current keymap (to show bindings in results) */\n  keymap?: HotkeyMap\n  /** Hotkey to open omnibar (default: 'meta+k') */\n  openKey?: string\n  /** Whether omnibar hotkey is enabled (default: true) */\n  enabled?: boolean\n  /** Called when an action is executed (if handlers not provided, or in addition to) */\n  onExecute?: (actionId: string) => void\n  /** Called when omnibar opens */\n  onOpen?: () => void\n  /** Called when omnibar closes */\n  onClose?: () => void\n  /** Maximum number of results to show (default: 10) */\n  maxResults?: number\n}\n\nexport interface UseOmnibarResult {\n  /** Whether omnibar is open */\n  isOpen: boolean\n  /** Open the omnibar */\n  open: () => void\n  /** Close the omnibar */\n  close: () => void\n  /** Toggle the omnibar */\n  toggle: () => void\n  /** Current search query */\n  query: string\n  /** Set the search query */\n  setQuery: (query: string) => void\n  /** Search results (filtered and sorted) */\n  results: ActionSearchResult[]\n  /** Currently selected result index */\n  selectedIndex: number\n  /** Select the next result */\n  selectNext: () => void\n  /** Select the previous result */\n  selectPrev: () => void\n  /** Execute the selected action (or a specific action by ID) */\n  execute: (actionId?: string) => void\n  /** Reset selection to first result */\n  resetSelection: () => void\n  /** Sequence completions based on pending keys */\n  completions: SequenceCompletion[]\n  /** Keys pressed so far in current sequence (from useHotkeys) */\n  pendingKeys: HotkeySequence\n  /** Whether currently awaiting more keys in a sequence */\n  isAwaitingSequence: boolean\n}\n\n/**\n * Hook for implementing an omnibar/command palette.\n *\n * @example\n * ```tsx\n * const ACTIONS: ActionRegistry = {\n *   'metric:temp': { label: 'Temperature', category: 'Metrics' },\n *   'metric:co2': { label: 'CO', category: 'Metrics' },\n *   'save': { label: 'Save', description: 'Save current settings' },\n * }\n *\n * function App() {\n *   const {\n *     isOpen, open, close,\n *     query, setQuery,\n *     results,\n *     selectedIndex, selectNext, selectPrev,\n *     execute,\n *   } = useOmnibar({\n *     actions: ACTIONS,\n *     handlers: HANDLERS,\n *     keymap: KEYMAP,\n *   })\n *\n *   return (\n *     <>\n *       {isOpen && (\n *         <div className=\"omnibar\">\n *           <input\n *             value={query}\n *             onChange={e => setQuery(e.target.value)}\n *             onKeyDown={e => {\n *               if (e.key === 'ArrowDown') selectNext()\n *               if (e.key === 'ArrowUp') selectPrev()\n *               if (e.key === 'Enter') execute()\n *               if (e.key === 'Escape') close()\n *             }}\n *           />\n *           {results.map((result, i) => (\n *             <div\n *               key={result.id}\n *               className={i === selectedIndex ? 'selected' : ''}\n *               onClick={() => execute(result.id)}\n *             >\n *               {result.action.label}\n *               {result.bindings.length > 0 && (\n *                 <kbd>{result.bindings[0]}</kbd>\n *               )}\n *             </div>\n *           ))}\n *         </div>\n *       )}\n *     </>\n *   )\n * }\n * ```\n */\nexport function useOmnibar(options: UseOmnibarOptions): UseOmnibarResult {\n  const {\n    actions,\n    handlers,\n    keymap = {},\n    openKey = 'meta+k',\n    enabled = true,\n    onExecute,\n    onOpen,\n    onClose,\n    maxResults = 10,\n  } = options\n\n  const [isOpen, setIsOpen] = useState(false)\n  const [query, setQuery] = useState('')\n  const [selectedIndex, setSelectedIndex] = useState(0)\n\n  // Refs for stable callbacks\n  const handlersRef = useRef(handlers)\n  handlersRef.current = handlers\n\n  const onExecuteRef = useRef(onExecute)\n  onExecuteRef.current = onExecute\n\n  // Register omnibar hotkey\n  const omnibarKeymap = useMemo(() => {\n    if (!enabled) return {}\n    return { [openKey]: 'omnibar:toggle' }\n  }, [enabled, openKey])\n\n  const { pendingKeys, isAwaitingSequence } = useHotkeys(\n    omnibarKeymap,\n    {\n      'omnibar:toggle': () => {\n        setIsOpen(prev => {\n          const next = !prev\n          if (next) {\n            onOpen?.()\n          } else {\n            onClose?.()\n          }\n          return next\n        })\n      },\n    },\n    { enabled },\n  )\n\n  // Search results\n  const results = useMemo(() => {\n    const allResults = searchActions(query, actions, keymap)\n    return allResults.slice(0, maxResults)\n  }, [query, actions, keymap, maxResults])\n\n  // Sequence completions (based on pending keys from main hotkey handler, not omnibar)\n  const completions = useMemo(() => {\n    return getSequenceCompletions(pendingKeys, keymap)\n  }, [pendingKeys, keymap])\n\n  // Reset selection when results change\n  useEffect(() => {\n    setSelectedIndex(0)\n  }, [results])\n\n  const open = useCallback(() => {\n    setIsOpen(true)\n    setQuery('')\n    setSelectedIndex(0)\n    onOpen?.()\n  }, [onOpen])\n\n  const close = useCallback(() => {\n    setIsOpen(false)\n    setQuery('')\n    setSelectedIndex(0)\n    onClose?.()\n  }, [onClose])\n\n  const toggle = useCallback(() => {\n    setIsOpen(prev => {\n      const next = !prev\n      if (next) {\n        setQuery('')\n        setSelectedIndex(0)\n        onOpen?.()\n      } else {\n        onClose?.()\n      }\n      return next\n    })\n  }, [onOpen, onClose])\n\n  const selectNext = useCallback(() => {\n    setSelectedIndex(prev => Math.min(prev + 1, results.length - 1))\n  }, [results.length])\n\n  const selectPrev = useCallback(() => {\n    setSelectedIndex(prev => Math.max(prev - 1, 0))\n  }, [])\n\n  const resetSelection = useCallback(() => {\n    setSelectedIndex(0)\n  }, [])\n\n  const execute = useCallback((actionId?: string) => {\n    const id = actionId ?? results[selectedIndex]?.id\n    if (!id) return\n\n    // Close omnibar\n    close()\n\n    // Call handler if available\n    if (handlersRef.current?.[id]) {\n      // Create a synthetic keyboard event\n      const event = new KeyboardEvent('keydown', { key: 'Enter' })\n      handlersRef.current[id](event)\n    }\n\n    // Call onExecute callback\n    onExecuteRef.current?.(id)\n  }, [results, selectedIndex, close])\n\n  // Handle keyboard navigation when open\n  useEffect(() => {\n    if (!isOpen) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Don't handle if focused on an input (let the input handle it)\n      const target = e.target as HTMLElement\n      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\n        // Still handle Escape to close\n        if (e.key === 'Escape') {\n          e.preventDefault()\n          close()\n        }\n        return\n      }\n\n      switch (e.key) {\n        case 'Escape':\n          e.preventDefault()\n          close()\n          break\n        case 'ArrowDown':\n          e.preventDefault()\n          selectNext()\n          break\n        case 'ArrowUp':\n          e.preventDefault()\n          selectPrev()\n          break\n        case 'Enter':\n          e.preventDefault()\n          execute()\n          break\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown)\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [isOpen, close, selectNext, selectPrev, execute])\n\n  return {\n    isOpen,\n    open,\n    close,\n    toggle,\n    query,\n    setQuery,\n    results,\n    selectedIndex,\n    selectNext,\n    selectPrev,\n    execute,\n    resetSelection,\n    completions,\n    pendingKeys,\n    isAwaitingSequence,\n  }\n}\n","import { useCallback, useMemo, useState } from 'react'\nimport type { HotkeyMap } from './useHotkeys'\nimport type { HotkeySequence, KeyCombination, KeyCombinationDisplay } from './types'\nimport { useRecordHotkey } from './useRecordHotkey'\nimport { findConflicts, formatCombination, parseCombinationId } from './utils'\n\nexport interface KeybindingEditorProps {\n  /** Current keymap */\n  keymap: HotkeyMap\n  /** Default keymap (for reset functionality) */\n  defaults: HotkeyMap\n  /** Descriptions for actions */\n  descriptions?: Record<string, string>\n  /** Called when a binding changes */\n  onChange: (action: string, key: string) => void\n  /** Called when reset is requested */\n  onReset?: () => void\n  /** CSS class for the container */\n  className?: string\n  /** Custom render function */\n  children?: (props: KeybindingEditorRenderProps) => React.ReactNode\n}\n\nexport interface KeybindingEditorRenderProps {\n  bindings: BindingInfo[]\n  editingAction: string | null\n  /** Keys already pressed and released (waiting for timeout or more keys) */\n  pendingKeys: HotkeySequence\n  /** Keys currently being held down */\n  activeKeys: KeyCombination | null\n  startEditing: (action: string) => void\n  cancelEditing: () => void\n  reset: () => void\n  conflicts: Map<string, string[]>\n}\n\nexport interface BindingInfo {\n  action: string\n  key: string\n  display: KeyCombinationDisplay\n  description: string\n  isDefault: boolean\n  hasConflict: boolean\n}\n\n/**\n * Build action -> key lookup from keymap\n */\nfunction buildActionMap(keymap: HotkeyMap): Map<string, string> {\n  const map = new Map<string, string>()\n  for (const [key, actionOrActions] of Object.entries(keymap)) {\n    const actions = Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions]\n    for (const action of actions) {\n      map.set(action, key)\n    }\n  }\n  return map\n}\n\n/**\n * UI component for editing keybindings.\n *\n * @example\n * ```tsx\n * <KeybindingEditor\n *   keymap={keymap}\n *   defaults={DEFAULT_KEYMAP}\n *   descriptions={{ save: 'Save document' }}\n *   onChange={(action, key) => setBinding(action, key)}\n *   onReset={() => reset()}\n * />\n * ```\n */\nexport function KeybindingEditor({\n  keymap,\n  defaults,\n  descriptions,\n  onChange,\n  onReset,\n  className,\n  children,\n}: KeybindingEditorProps) {\n  const [editingAction, setEditingAction] = useState<string | null>(null)\n\n  const actionMap = useMemo(() => buildActionMap(keymap), [keymap])\n  const defaultActionMap = useMemo(() => buildActionMap(defaults), [defaults])\n  const conflicts = useMemo(() => findConflicts(keymap), [keymap])\n\n  const { isRecording, startRecording, cancel, pendingKeys, activeKeys } = useRecordHotkey({\n    onCapture: useCallback(\n      (_sequence: HotkeySequence, display: KeyCombinationDisplay) => {\n        if (editingAction) {\n          onChange(editingAction, display.id)\n          setEditingAction(null)\n        }\n      },\n      [editingAction, onChange],\n    ),\n    onCancel: useCallback(() => {\n      setEditingAction(null)\n    }, []),\n  })\n\n  const startEditing = useCallback(\n    (action: string) => {\n      setEditingAction(action)\n      startRecording()\n    },\n    [startRecording],\n  )\n\n  const cancelEditing = useCallback(() => {\n    cancel()\n    setEditingAction(null)\n  }, [cancel])\n\n  const reset = useCallback(() => {\n    onReset?.()\n  }, [onReset])\n\n  // Format keys for display during recording\n  // Shows pendingKeys (released keys) + activeKeys (currently held)\n  const getRecordingDisplay = () => {\n    // Nothing pressed yet\n    if (pendingKeys.length === 0 && (!activeKeys || !activeKeys.key)) {\n      return 'Press keys...'\n    }\n\n    // Format pending keys (already pressed and released)\n    let display = pendingKeys.length > 0 ? formatCombination(pendingKeys).display : ''\n\n    // Add currently held keys\n    if (activeKeys && activeKeys.key) {\n      if (display) display += '  '\n      display += formatCombination([activeKeys]).display\n    }\n\n    // Ellipsis indicates we're waiting for timeout or more keys\n    return display + '...'\n  }\n\n  // Build binding info for all actions\n  const bindings: BindingInfo[] = useMemo(() => {\n    const allActions = new Set([...actionMap.keys(), ...defaultActionMap.keys()])\n\n    return Array.from(allActions).map((action) => {\n      const key = actionMap.get(action) ?? defaultActionMap.get(action) ?? ''\n      const defaultKey = defaultActionMap.get(action) ?? ''\n      const combo = parseCombinationId(key)\n      const display = formatCombination(combo)\n      const conflictActions = conflicts.get(key)\n\n      return {\n        action,\n        key,\n        display,\n        description: descriptions?.[action] ?? action,\n        isDefault: key === defaultKey,\n        hasConflict: conflictActions !== undefined && conflictActions.length > 1,\n      }\n    }).sort((a, b) => a.action.localeCompare(b.action))\n  }, [actionMap, defaultActionMap, descriptions, conflicts])\n\n  // Custom render\n  if (children) {\n    return (\n      <>\n        {children({\n          bindings,\n          editingAction,\n          pendingKeys,\n          activeKeys,\n          startEditing,\n          cancelEditing,\n          reset,\n          conflicts,\n        })}\n      </>\n    )\n  }\n\n  // Default render\n  return (\n    <div className={className}>\n      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>\n        <h3 style={{ margin: 0 }}>Keybindings</h3>\n        {onReset && (\n          <button\n            onClick={reset}\n            style={{\n              padding: '6px 12px',\n              backgroundColor: '#f5f5f5',\n              border: '1px solid #ddd',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n          >\n            Reset to defaults\n          </button>\n        )}\n      </div>\n\n      <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n        <thead>\n          <tr>\n            <th style={{ textAlign: 'left', padding: '8px', borderBottom: '2px solid #ddd' }}>Action</th>\n            <th style={{ textAlign: 'left', padding: '8px', borderBottom: '2px solid #ddd' }}>Keybinding</th>\n            <th style={{ width: '80px', padding: '8px', borderBottom: '2px solid #ddd' }}></th>\n          </tr>\n        </thead>\n        <tbody>\n          {bindings.map(({ action, display, description, isDefault, hasConflict }) => {\n            const isEditing = editingAction === action\n\n            return (\n              <tr key={action} style={{ backgroundColor: hasConflict ? '#fff3cd' : undefined }}>\n                <td style={{ padding: '8px', borderBottom: '1px solid #eee' }}>\n                  {description}\n                  {!isDefault && (\n                    <span style={{ marginLeft: '8px', fontSize: '0.75rem', color: '#666' }}>(modified)</span>\n                  )}\n                </td>\n                <td style={{ padding: '8px', borderBottom: '1px solid #eee' }}>\n                  {isEditing ? (\n                    <kbd\n                      style={{\n                        backgroundColor: '#e3f2fd',\n                        padding: '4px 8px',\n                        borderRadius: '4px',\n                        border: '2px solid #2196f3',\n                        fontFamily: 'monospace',\n                      }}\n                    >\n                      {getRecordingDisplay()}\n                    </kbd>\n                  ) : (\n                    <kbd\n                      style={{\n                        backgroundColor: '#f5f5f5',\n                        padding: '4px 8px',\n                        borderRadius: '4px',\n                        border: '1px solid #ddd',\n                        fontFamily: 'monospace',\n                      }}\n                    >\n                      {display.display}\n                    </kbd>\n                  )}\n                  {hasConflict && !isEditing && (\n                    <span style={{ marginLeft: '8px', color: '#856404', fontSize: '0.75rem' }}> Conflict</span>\n                  )}\n                </td>\n                <td style={{ padding: '8px', borderBottom: '1px solid #eee', textAlign: 'center' }}>\n                  {isEditing ? (\n                    <button\n                      onClick={cancelEditing}\n                      style={{\n                        padding: '4px 8px',\n                        backgroundColor: '#f5f5f5',\n                        border: '1px solid #ddd',\n                        borderRadius: '4px',\n                        cursor: 'pointer',\n                        fontSize: '0.875rem',\n                      }}\n                    >\n                      Cancel\n                    </button>\n                  ) : (\n                    <button\n                      onClick={() => startEditing(action)}\n                      disabled={isRecording}\n                      style={{\n                        padding: '4px 8px',\n                        backgroundColor: '#f5f5f5',\n                        border: '1px solid #ddd',\n                        borderRadius: '4px',\n                        cursor: isRecording ? 'not-allowed' : 'pointer',\n                        fontSize: '0.875rem',\n                        opacity: isRecording ? 0.5 : 1,\n                      }}\n                    >\n                      Edit\n                    </button>\n                  )}\n                </td>\n              </tr>\n            )\n          })}\n        </tbody>\n      </table>\n    </div>\n  )\n}\n","import { useCallback, useEffect, useState } from 'react'\nimport type { HotkeyMap } from './useHotkeys'\nimport { useHotkeys } from './useHotkeys'\nimport { formatCombination, parseCombinationId } from './utils'\n\nexport interface ShortcutGroup {\n  name: string\n  shortcuts: Array<{ key: string; action: string; description?: string }>\n}\n\nexport interface ShortcutsModalProps {\n  /** The hotkey map to display */\n  keymap: HotkeyMap\n  /** Descriptions for actions (action name -> description) */\n  descriptions?: Record<string, string>\n  /** Group definitions (if omitted, actions are grouped by prefix before ':') */\n  groups?: Record<string, string>\n  /** Control visibility externally */\n  isOpen?: boolean\n  /** Called when modal should close */\n  onClose?: () => void\n  /** Hotkey to open modal (default: '?') */\n  openKey?: string\n  /** Whether to auto-register the open hotkey (default: true) */\n  autoRegisterOpen?: boolean\n  /** Custom render function for the modal content */\n  children?: (props: { groups: ShortcutGroup[]; close: () => void }) => React.ReactNode\n  /** CSS class for the backdrop */\n  backdropClassName?: string\n  /** CSS class for the modal container */\n  modalClassName?: string\n}\n\n/**\n * Parse action name to extract group.\n * e.g., \"metric:temp\" -> { group: \"metric\", action: \"temp\" }\n */\nfunction parseAction(action: string): { group: string; name: string } {\n  const colonIndex = action.indexOf(':')\n  if (colonIndex > 0) {\n    return { group: action.slice(0, colonIndex), name: action.slice(colonIndex + 1) }\n  }\n  return { group: 'General', name: action }\n}\n\n/**\n * Organize keymap into groups for display.\n */\nfunction organizeShortcuts(\n  keymap: HotkeyMap,\n  descriptions?: Record<string, string>,\n  groupNames?: Record<string, string>,\n): ShortcutGroup[] {\n  const groupMap = new Map<string, ShortcutGroup>()\n\n  for (const [key, actionOrActions] of Object.entries(keymap)) {\n    const actions = Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions]\n\n    for (const action of actions) {\n      const { group: groupKey, name } = parseAction(action)\n      const groupName = groupNames?.[groupKey] ?? groupKey\n\n      if (!groupMap.has(groupName)) {\n        groupMap.set(groupName, { name: groupName, shortcuts: [] })\n      }\n\n      groupMap.get(groupName)!.shortcuts.push({\n        key,\n        action,\n        description: descriptions?.[action] ?? name,\n      })\n    }\n  }\n\n  // Sort groups: \"General\" last, others alphabetically\n  return Array.from(groupMap.values()).sort((a, b) => {\n    if (a.name === 'General') return 1\n    if (b.name === 'General') return -1\n    return a.name.localeCompare(b.name)\n  })\n}\n\n/**\n * Modal component for displaying keyboard shortcuts.\n *\n * @example\n * ```tsx\n * <ShortcutsModal\n *   keymap={HOTKEYS}\n *   descriptions={{ 'metric:temp': 'Switch to temperature view' }}\n * />\n * ```\n */\nexport function ShortcutsModal({\n  keymap,\n  descriptions,\n  groups: groupNames,\n  isOpen: controlledIsOpen,\n  onClose,\n  openKey = '?',\n  autoRegisterOpen = true,\n  children,\n  backdropClassName,\n  modalClassName,\n}: ShortcutsModalProps) {\n  const [internalIsOpen, setInternalIsOpen] = useState(false)\n  const isOpen = controlledIsOpen ?? internalIsOpen\n\n  const close = useCallback(() => {\n    setInternalIsOpen(false)\n    onClose?.()\n  }, [onClose])\n\n  const open = useCallback(() => {\n    setInternalIsOpen(true)\n  }, [])\n\n  // Register open/close hotkeys\n  const modalKeymap = autoRegisterOpen ? { [openKey]: 'openShortcuts' } : {}\n  useHotkeys(\n    { ...modalKeymap, escape: 'closeShortcuts' },\n    {\n      openShortcuts: open,\n      closeShortcuts: close,\n    },\n    { enabled: autoRegisterOpen || isOpen },\n  )\n\n  // Close on backdrop click\n  const handleBackdropClick = useCallback(\n    (e: React.MouseEvent) => {\n      if (e.target === e.currentTarget) {\n        close()\n      }\n    },\n    [close],\n  )\n\n  // Organize shortcuts into groups\n  const shortcutGroups = organizeShortcuts(keymap, descriptions, groupNames)\n\n  if (!isOpen) return null\n\n  // Custom render\n  if (children) {\n    return <>{children({ groups: shortcutGroups, close })}</>\n  }\n\n  // Default render\n  return (\n    <div\n      className={backdropClassName}\n      onClick={handleBackdropClick}\n      style={\n        backdropClassName\n          ? undefined\n          : {\n              position: 'fixed',\n              inset: 0,\n              backgroundColor: 'rgba(0, 0, 0, 0.5)',\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              zIndex: 9999,\n            }\n      }\n    >\n      <div\n        className={modalClassName}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-label=\"Keyboard shortcuts\"\n        style={\n          modalClassName\n            ? undefined\n            : {\n                backgroundColor: 'white',\n                borderRadius: '8px',\n                padding: '24px',\n                maxWidth: '600px',\n                maxHeight: '80vh',\n                overflow: 'auto',\n                boxShadow: '0 4px 20px rgba(0, 0, 0, 0.15)',\n              }\n        }\n      >\n        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>\n          <h2 style={{ margin: 0, fontSize: '1.25rem', fontWeight: 600 }}>Keyboard Shortcuts</h2>\n          <button\n            onClick={close}\n            aria-label=\"Close\"\n            style={{\n              background: 'none',\n              border: 'none',\n              fontSize: '1.5rem',\n              cursor: 'pointer',\n              padding: '4px',\n              lineHeight: 1,\n            }}\n          >\n            \n          </button>\n        </div>\n\n        {shortcutGroups.map((group) => (\n          <div key={group.name} style={{ marginBottom: '16px' }}>\n            <h3 style={{ margin: '0 0 8px', fontSize: '0.875rem', fontWeight: 600, textTransform: 'uppercase', color: '#666' }}>\n              {group.name}\n            </h3>\n            <dl style={{ margin: 0 }}>\n              {group.shortcuts.map(({ key, action, description }) => {\n                const combo = parseCombinationId(key)\n                const display = formatCombination(combo)\n                return (\n                  <div\n                    key={action}\n                    style={{ display: 'flex', justifyContent: 'space-between', padding: '4px 0', borderBottom: '1px solid #eee' }}\n                  >\n                    <dt style={{ color: '#333' }}>{description}</dt>\n                    <dd style={{ margin: 0, fontFamily: 'monospace', color: '#666' }}>\n                      <kbd style={{ backgroundColor: '#f5f5f5', padding: '2px 6px', borderRadius: '4px', border: '1px solid #ddd' }}>\n                        {display.display}\n                      </kbd>\n                    </dd>\n                  </div>\n                )\n              })}\n            </dl>\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n"]}